<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Constraints · SumOfSquares</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SumOfSquares</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Index</a></li><li><a class="toctext" href="sumofsquares.html">Sum-of-Squares Programming</a></li><li><a class="toctext" href="variables.html">Variables</a></li><li class="current"><a class="toctext" href="constraints.html">Constraints</a><ul class="internal"><li><a class="toctext" href="#Equality-constraints-between-polynomials-1">Equality constraints between polynomials</a></li><li><a class="toctext" href="#Inequality-constraints-between-polynomials-1">Inequality constraints between polynomials</a></li><li><a class="toctext" href="#Changing-the-polynomial-basis-1">Changing the polynomial basis</a></li><li><a class="toctext" href="#Polynomial-nonnegativity-on-a-subset-of-the-space-1">Polynomial nonnegativity on a subset of the space</a></li><li><a class="toctext" href="#Dual-of-polynomial-constraints-1">Dual of polynomial constraints</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="constraints.html">Constraints</a></li></ul><a class="edit-page" href="https://github.com/JuliaOpt/SumOfSquares.jl/blob/master/docs/src/constraints.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Constraints</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Constraints-1" href="#Constraints-1">Constraints</a></h1><h2><a class="nav-anchor" id="Equality-constraints-between-polynomials-1" href="#Equality-constraints-between-polynomials-1">Equality constraints between polynomials</a></h2><p>Equality between polynomials in <a href="https://github.com/JuliaOpt/PolyJuMP.jl">PolyJuMP</a> uses the same syntax as equality between affine or quadratic expression in <a href="https://github.com/JuliaOpt/JuMP.jl">JuMP</a>. For instance, creating two quadratic <code>n</code>-variate polynomials <code>p</code> and <code>q</code> that must sum up to one can be done as follows:</p><pre><code class="language-julia">using DynamicPolynomials
@polyvar x[1:n]
using MultivariatePolynomials
X = monomials(x, 0:2)
using PolyJuMP
@variable(model, p, Poly(X))
@variable(model, q, Poly(X))
@constraint(model, p + q == 1)</code></pre><p>Vectorized constraints can also be used as well as vector of constraints, named constraints, ... For instance instance, if <code>P</code> and <code>Q</code> are two <span>$n \times n$</span> matrices of polynomials, the following constraints the sum of rows and columns to match</p><pre><code class="language-julia">@constraint(model, con[i=1:n], sum(P[i, :]) == sum(Q[:, i]))</code></pre><p>and <code>con[i]</code> contains the reference to the constraint between the <code>i</code>th row of <code>P</code> and the <code>i</code>th column of <code>Q</code>.</p><h2><a class="nav-anchor" id="Inequality-constraints-between-polynomials-1" href="#Inequality-constraints-between-polynomials-1">Inequality constraints between polynomials</a></h2><p>Polynomials can be constrained to be sum-of-squares with the <code>in</code> syntax. For instance, to constraints a polynomial <code>p</code> to be sum-of-squares, do</p><pre><code class="language-julia">@constraint(model, p in SOSCone())</code></pre><h3><a class="nav-anchor" id="Automatically-interpreting-polynomial-nonnegativity-as-a-sum-of-squares-constraint-1" href="#Automatically-interpreting-polynomial-nonnegativity-as-a-sum-of-squares-constraint-1">Automatically interpreting polynomial nonnegativity as a sum-of-squares constraint</a></h3><p>As detailed in <a href="sumofsquares.html#When-is-nonnegativity-equivalent-to-sum-of-squares-?-1">When is nonnegativity equivalent to sum of squares ?</a>, the nonnegativity of a polynomial is not equivalent to the existence of a sum-of-squares decomposition. However, if explicitely specified, nonnegativity constraints can be automatically interpreted as sum-of-squares constraints. The simplest way to do that is to create the model with</p><pre><code class="language-julia">model = SOSModel(...)</code></pre><p>instead of</p><pre><code class="language-julia">model = Model(...)</code></pre><p>An alternative equivalent way is to call <code>setpolymodule!</code> after creating the model:</p><pre><code class="language-julia">setpolymodule!(model, SumOfSquares)</code></pre><p>This second approach may be useful if the SumOfSquares JuMP extension need to be used with another JuMP extension that also has a special model constructor. A third alternative is the following:</p><pre><code class="language-julia">PolyJuMP.setdefault!(model, PolyJuMP.NonNegPoly, SOSCone)
PolyJuMP.setdefault!(model, PolyJuMP.NonNegPolyMatrix, SOSMatrixCone)</code></pre><p>This approach adds the flexibility to choose the default cone for</p><ul><li><p>constraints of the form <code>@constraint(mode, ..., some_polynomial ≥ other_polynomial, ...)</code> which is the cone given as default to <code>PolyJuMP.NonNegPoly</code>; and</p></li><li><p>constraints of the form <code>@constraint(mode, ..., some_matrix_of_polynomial in PSDCone(), ...)</code> or <code>@SDconstraint(mode, ..., some_matrix_of_polynomial ⪰ other_matrix_of_polynomial, ...)</code> which is the cone given as default to <code>PolyJuMP.NonNegPolyMatrix</code>.</p></li></ul><p>For instance, to use the diagonally-dominant-sum-of-squares cone (see [Definition 2, AM17]) for the first type of contraints, do</p><pre><code class="language-julia">PolyJuMP.setdefault!(model, PolyJuMP.NonNegPoly, DSOSCone)</code></pre><h2><a class="nav-anchor" id="Changing-the-polynomial-basis-1" href="#Changing-the-polynomial-basis-1">Changing the polynomial basis</a></h2><p>As introduced in <a href="variables.html#Choosing-a-polynomial-basis-1">Choosing a polynomial basis</a>, there may be numerical advantages to use another basis than the standard monomial basis when creating polynomial variables. Similarly, other polynomial basis can be used for polynomial constraints. However, for constraints, the polynomial space is determined by the polynomial constrained to be nonnegative. For instance, consider the constraint:</p><pre><code class="language-julia">@constraint(model, α * x^2 + β * y^2 ≥ (α - β) * x * y)</code></pre><p>where <code>α</code> and <code>β</code> are JuMP decision variables and <code>x</code> and <code>y</code> are polynomial variables. Since the polynomial is a quadratic form, the sum-of-squares certificate is also a quadratic form (see [Section~3.3.4, BPT12]). Hence the default polynomial basis used for the [Nonnegative polynomial variables] certificate is <code>MonomialBasis([x, y])</code>, that is, we search for a positive semidefinite matrix <code>Q</code> such that</p><div>\[α * x^2 + β * y^2 - (α - β) * x * y = X^\top Q X\]</div><p>where <span>$X = (x, y)$</span>.</p><p>As the polynomial space is determined by the polynomial being constrained, only the basis <em>type</em> need to be given.For instance, to use the scaled monomial basis, use</p><pre><code class="language-julia">@constraint(model, p ≥ q, basis = ScaledMonomialBasis)</code></pre><h2><a class="nav-anchor" id="Polynomial-nonnegativity-on-a-subset-of-the-space-1" href="#Polynomial-nonnegativity-on-a-subset-of-the-space-1">Polynomial nonnegativity on a subset of the space</a></h2><p>By default, the constraint</p><pre><code class="language-julia">@constraint(model, x^3 - x^2 + 2x*y -y^2 + y^3 &gt;= α)</code></pre><p>constrains the polynomial to be nonnegative for every real numbers <code>x</code> and <code>y</code>. However, the set of points <code>(x, y)</code> for which the polynomial is constrained to be nonnegative can be specified by the <code>domain</code> keyword:</p><pre><code class="language-julia">using SemialgebraicSets
S = @set x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x + y &gt;= 1
@constraint(model, x^3 - x^2 + 2x*y -y^2 + y^3 &gt;= α, domain = S)</code></pre><p>See <a href="https://github.com/JuliaOpt/SumOfSquares.jl/blob/master/examples/Polynomial_Optimization.ipynb">this notebook</a> for a detailed example.</p><h2><a class="nav-anchor" id="Dual-of-polynomial-constraints-1" href="#Dual-of-polynomial-constraints-1">Dual of polynomial constraints</a></h2><p>The dual of a polynomial constraint <code>cref</code> is a moment serie <code>μ</code> as defined in <a href="https://github.com/JuliaAlgebra/MultivariateMoments.jl">MultivariateMoments</a>. The dual can be obtained with the <code>JuMP.resultdual</code> function as with classical dual values in JuMP. The matrix of moment can be obtaine as follows:</p><pre><code class="language-julia">μ = JuMP.resultdual(cref)
ν = matmeasure(μ, certificate_monomials(cref))</code></pre><p>The <code>extractatoms</code> function of <a href="https://github.com/JuliaAlgebra/MultivariateMoments.jl">MultivariateMoments</a> can be used to check if there exists an <em>atomic</em> measure (i.e. a measure that is a sum of Dirac measures) for that has the moments given in <code>ν</code>. This can be used for instance in polynomial optimization (see <a href="https://github.com/JuliaOpt/SumOfSquares.jl/blob/master/examples/Polynomial_Optimization.ipynb">this notebook</a>) or stability analysis (see <a href="https://github.com/blegat/SwitchOnSafety.jl/blob/master/examples/LPJ17e43.ipynb">this notebook</a>).</p><h3><a class="nav-anchor" id="References-1" href="#References-1">References</a></h3><p>[BPT12] Blekherman, G.; Parrilo, P. A. &amp; Thomas, R. R. <em>Semidefinite Optimization and Convex Algebraic Geometry</em>. Society for Industrial and Applied Mathematics, 2012.</p><p>[AM17] Ahmadi, A. A. &amp; Majumdar, A. <em>DSOS and SDSOS Optimization: More Tractable Alternatives to Sum of Squares and Semidefinite Optimization</em> ArXiv e-prints, 2017</p><footer><hr/><a class="previous" href="variables.html"><span class="direction">Previous</span><span class="title">Variables</span></a></footer></article></body></html>
